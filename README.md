
# N-Queens Puzzle Solver

A Python-based solver for the classic N-Queens problem, which implements multiple search strategies to efficiently find solutions for large board sizes.

> An example of a solved 8x8 N-Queens board generated by the program.

---

## Overview

This project provides a robust solver for the N-Queens problem, a classic computer science puzzle that challenges you to place N chess queens on an NÃ—N chessboard so that no two queens threaten each other. The program is designed to be interactive, prompting the user for a board size and then applying multiple search algorithms to find and display a valid solution. It demonstrates the application of both exhaustive and heuristic-based search techniques.

---

## Features

- **Dual Algorithm Implementation**: Solves the puzzle using both Depth-First Search (DFS) for a direct, recursive solution path, and a best-first search (a Breadth-First Search with a priority queue) to explore the most promising options first.

- **Constraint Satisfaction**: At its core is an `is_safe` function that checks each potential queen placement against the rules of chess, ensuring no two queens share the same row, column, or diagonal.

- **Scalable Performance**: The program is capable of solving for large values of N, successfully finding solutions for boards as large as 31x31.

- **Visual Output**: Renders a clear, text-based representation of the final board with the queens' positions.

---

## How It Works

The solver's logic is centered around the `is_safe` function, which validates every potential move.

### Depth-First Search (`solve_dfs`)

This function uses recursion to explore potential queen placements column by column. It backtracks whenever it hits a dead end, abandoning paths that cannot lead to a solution.

### Best-First Search (`solve_bfs`)

This function uses a priority queue (`heapq`) to manage open states. A custom heuristic, `Score`, evaluates and prioritizes states that have more potential safe moves for the next column, guiding the search toward a solution more efficiently.

---

## Code Snippet: The `is_safe` Function

This function is crucial for validating queen placements. It checks if placing a new queen at `(row, col)` conflicts with any existing queens on the board.

```python
def is_safe(board, row, col):
    i = 0
    while i < len(board):
        if board[i] == row:  # Check same row
            return False
        # Check diagonals
        if (board[i] + i) == (row + col) or (board[i] - i) == (row - col):
            return False
        i += 1
    return True
```

---

## Technologies Used

- **Language**: Python
- **Key Libraries**: `heapq` (for the priority queue in BFS)
- **Core Concepts**: Depth-First Search (DFS), Breadth-First Search (BFS), Heuristics, Priority Queues, Constraint Satisfaction, Recursion

---

## Getting Started

### Run the script from your terminal:

```bash
python n_queens_solver.py
```

### Enter the board size when prompted (e.g., 8).

The program will output the solutions found by both DFS and BFS.

